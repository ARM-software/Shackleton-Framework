The editor_tool edits the Shackleton framework by adding a new object type to the framework which can then be used as an internal object in the osaka structure.

This tool makes the following changes to the structure of Shackleton:

- Creates a new autogen_<name>.h file where <name> is the name of the new object type as specified by the user. All .h module files are built off of the simple.h template with added object items and macros based on user input
- Creates a new autogen_<name>.c file where <name> is the name of the new object type as specified by the user. All .h module files are built off of the simple.c template and contain implementations of the methods described in autogen_<name>.h
- Edits shackleton/osaka/osaka.h by adding a new entry in the osaka_object_type enum declaration. This gives the item a name and a number which must match that which appears in module/modules.c
- Edits shackleton/modules.h to add a new item to the object_table_function array along with new versions of all osaka object methods. This tool also increased the MAXTYPE variable by 1 to account for the new type
- Edits shackleton/module/modules.c to add a new include statement for the .h file created and described above
- Edits the shackleton/makefile by adding a new object declaration for autogen_<name>.o and adding a new build statement for the .h and .c created and described above
- Edits the evolution/fitness.c file by adding a default method specific to the newly added object type, adding a conditional statement in the fitness_top method for calling it for that object type, and adding a line in the fitness_setup method for setting its function pointer to the newly created method
- Edits the evolution/fitness.h file by adding a definition of a new fitness method for the newly added object type, as well as a definition of a function pointer to the newly created method.

This tool is a work in progress and may still have bugs to work out. It is recommended that a backup of all edited files listed above be created in the case that the autogenerated documents do not compile/make.

In order to add a new object type that has internal parameters, a new object type json file must be supplied. Here is an example of such a file:

{

    "object": {
        "name": "test_params"
    },
    "params": [
        {
            "name": "number",
            "type": "uint32_t",
            "macro_name": "my_number",
            "has_valid_values" : "false"
        },
        {
            "name": "binary",
            "type": "uint32_t",
            "macro_name": "my_binary",
            "has_valid_values" : "true",
            "values" : [
                {
                    "value": 1
                },
                {
                    "value": 2
                },
                {
                    "value": 4
                }, 
                {
                    "value": 8
                }, 
                {
                    "value": 16
                }, 
                {
                    "value": 32
                }, 
                {
                    "value": 64
                }, 
                {
                    "value": 128
                }, 
                {
                    "value": 256
                }, 
                {
                    "value": 512
                }
            ] 
        }
    ]
    
}


The new parameters file should always have two top-most items: object and params. The object name category is an additional name that adds a layer of redundancy to avoid duplicate naming across files in the tool.

The "params" array is where the parameters themselves need to be described. Every parameter is required to have 4 objects inside of it:
-   "name" - the name appended to the struct name that will be created
-   "type" - the C compliant datatype. Right now the approved datatypes are uint32_t, int, and char*
-   "macro_name" - the name of a macro that will be used to access the value of the struct created
-   "has_valid_values" - a string field that must either be "true" or "false". If "false", then the struct created will not enforce what values can be put into that variable If "true", then you are required to create an addition member of the param called "values" which is an array of valid values.

The example shown above is an example of a new object type that will create two new internal parameters and thus two new structs in the autogenerated files. One of the params shown does not have valid value constraints, while the other does.